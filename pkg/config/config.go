package config

import (
	"bytes"
	"fmt"
	"reflect"
	"sort"
	"strconv"
	"strings"

	"github.com/pelletier/go-toml"
)

// Config for the DC/OS CLI. The "core" and "cluster" sections are mapped to structs.
// Additional sections such as "marathon" are stored in a Tree.
// This difference is due to the fact that we know the content of "core" and "cluster"
// but not the content of additional sections.
type Config struct {
	Core    core    `toml:"core"`
	Cluster cluster `toml:"cluster"`
	tree    *toml.Tree
}

type core struct {
	// The public master URL of the DC/OS cluster.
	URL string `toml:"dcos_url"`

	// The token generated by authenticating to DC/OS using the Admin Router Access Control Service.
	ACSToken string `toml:"dcos_acs_token"`

	// Whether to verify SSL certs for HTTPS or path to certs. Valid values are:
	// - A path to a CA_BUNDLE.
	// - 1, t, T, TRUE, true, True - will use CA Certificates from certifi.
	// - 0, f, F, FALSE, false, False - will send insecure requests.
	SSL ssl `toml:"ssl_verify"`

	// Request timeout in seconds once the connection is established.
	Timeout int `toml:timeout`

	// Whether to use a different default username for node SSH access
	SSHUser string `toml:ssh_user`

	// Whether to use a fixed ssh proxy host (Bastion) for node SSH access
	SSHProxyIP string `toml:ssh_proxy_ip`

	// Whether to paginate the output of the commands.
	Pagination bool `toml:pagination`

	// Whether to report usage events to Mesosphere.
	Reporting bool `toml:reporting`

	// The Mesos master URL. Must be set in format "http://host:port".
	MesosMasterURL string `toml:mesos_master_url`

	// Whether to prompt the user to log in when token expired.
	// If set to `false`, otherwise automatically initiate login
	PrompLogin bool `toml:prompt_login`
}

type cluster struct {
	Name string `toml:"name"`
}

//
type ssl string

// Returns the value of a ssl variable as a bool. Defaults to false.
func (v ssl) Insecure() bool {
	if b, err := strconv.ParseBool(string(v)); err == nil {
		return !b
	}
	return false
}

// Returns the value of a ssl variable as a string. Defaults to "".
func (v ssl) CAPath() string {
	if _, err := strconv.ParseBool(string(v)); err == nil {
		return ""
	}
	return string(v)
}

// Returns a Config struct using a path to a .toml file.
func FromPath(path string) (Config, error) {
	tree, err := toml.LoadFile(path)
	if err != nil {
		return Config{}, err
	}
	return fromTree(tree)
}

// Returns a Config struct using a string.
func FromString(tomlData string) (Config, error) {
	tree, err := toml.Load(tomlData)
	if err != nil {
		return Config{}, err
	}
	return fromTree(tree)
}

// Returns a Config struct as a string.
func (config Config) String() string {
	// The order of the sections can vary using this method. We have to sort them.
	sections := config.tree.Keys()

	// Sorts sections alphabetically, except for "core" and "cluster"
	// as we want these sections to be the first and second ones displayed.
	firstSections := [2]string{"core", "cluster"}
	sort.SliceStable(sections, func(i, j int) bool {
		for _, section := range firstSections {
			if sections[i] == section || sections[j] == section {
				return sections[i] == section
			}
		}
		return sections[i] < sections[j]
	})

	// Transforms the ordered sections into a string.
	var configString string
	for _, section := range sections {
		if sectionStr, err := config.StringAt([]string{section}); err == nil {
			configString += sectionStr
		}
	}

	return configString
}

// core.dcos_url = [core, dcos_url]
func (config Config) StringAt(key []string) (string, error) {
	val := config.get(key)

	switch value := val.(type) {
	case *toml.Tree:
		var buf bytes.Buffer
		// Walks tree leaves and prints their value prefixed by their key
		visitLeaves(value, key, func(leaf interface{}, nodeKeys []string) {
			strVal := fmt.Sprintf("%v\n", leaf)
			strKey := strings.Join(nodeKeys, ".")
			buf.Write([]byte(fmt.Sprintf("%s %v", strKey, strVal)))
		})
		return buf.String(), nil
	default:
		// this is a well-known field or a leaf holding an interface value
		// we can print, there is no need to print the key before the value
		if value == nil {
			strKey := strings.Join(key, ".")
			return "", fmt.Errorf("unknown config key \"%s\"", strKey)
		}
		return fmt.Sprintf("%v\n", val), nil
	}
}

func (c core) String() string {
	configString := fmt.Sprintf("%s %v\n", "core.dcos_acs_token", "********")
	configString += fmt.Sprintf("%s %v\n", "core.dcos_url", c.URL)
	configString += fmt.Sprintf("%s %v", "core.ssl_verify", c.SSL)

	return configString
}

func (c cluster) String() string {
	return fmt.Sprintf("%s %v", "cluster.name", c.Name)
}

func fromTree(tree *toml.Tree) (Config, error) {
	var config Config
	if err := tree.Unmarshal(&config); err != nil {
		return config, err
	}

	config.tree = tree

	return config, nil
}

func (config Config) get(key []string) interface{} {
	if len(key) == 0 {
		panic("no key specified")
	}
	keyPos := 0
	keyLen := len(key)

	t := reflect.TypeOf(config)
	v := reflect.ValueOf(config)
redo:
	for i := 0; t.Kind() == reflect.Struct && i < t.NumField(); i++ {
		field := t.Field(i)
		val, ok := field.Tag.Lookup("toml")
		if ok && val == key[keyPos] {
			t = field.Type
			v = v.FieldByName(field.Name)
			keyPos++

			if keyPos == keyLen {
				return v.Interface()
			}
			goto redo
		}
	}
	return config.tree.GetPath(key)
}
